package elevFunc

import (
	"orderRegister"
	"driver"
	."time"
	"udp"
)


var floor := -1;
var last_floor := 0;
var direction := -1;	// -1 = står i ro, 1 = opp, 0 = ned
var doorOpen := false;

send_ch := make(chan Udp_message)
receive_ch := make(chan Udp_message)


//Elevfunc skal ha initfunksjon, alle elevfunksjoner og de fleste variabler, troooor jeg

func Init(localPort chan, broadcastPort chan, message_size int) {

	err := Udp_Init(localPort, broadcastPort, message_size, send_ch, receive_ch)
	if err {
		println("Error during udp-init")
		break
	}
	elev_init()		//Fra driver.go
	for (elev_get_floor_sensor_signal() != 0) {
		elev_set_speed (-300)
	}
	elev_set_speed(50)
	Sleep(20000*Microsecond)
	elev_set_speed(0)
	elev_set_floor_indicator(0)	
	direction = -1
	lastFloor = -1
}




func floorReached(floor int) {
	last_floor = floor
	elev_set_floor_indicator(floor)		//set light on floor
	
	if (getOrder(direction, floor) {
		if (direction == 1) {
			elev_set_speed(100)
		} if (direction == 0) {
			elev_set_speed(-100)
		}
		Sleep(20000*Microsecond)
		elev_set_speed(0)
		elev_set_door_open_lamp(1)
		doorOpen(true)
		go openDoor()
		
	} else if (floor == 0) {			//Stops, so the elevator do not pass 1. floor
		elev_set_speed(100)
		Sleep(20000*Microsecond)
		elev_set_speed(0)
		direction = 0
		runElevator()
		
	} else if (floor == 3) {			//Stops, so the elevator do not pass 4. floor
		elev_set_speed(-100)
		Sleep(20000*Microsecond)
		elev_set_speed(0)
		direction = 1
		runElevator()
	}
	
}



func orderHandled() {
	
}



func runElevator() {
	
	if doorOpen {
		return
	}
	
	if (emptyQueue()) {
		direction = -1
		
	} else {
	
		if (direction == 0) {
			elev_set_speed(300)
		} else if (direction == 1) {
			elev_set_speed(-300)
		}
	}
}



//Calculates cost
func getCost(floor, orderFloor, direction, last_floor) int {
	cost := //KOSTFUNKSJON
	return cost
}




func SendOrder(order Order) {

	b, err := json.Marshal(order)
	
	if (err != nil) {
		println("Send Order Error: ", err)
	}
	
	exit := make(chan string)
	go UDPSend(exit, b)
	exit <- "message sent!"	
}




//Receives orders from other elevators
func ReceiveOrder() Order {
	
	b := UDPListen()
	
	var receivedOrder Order
	err := json.Unmarshal(b, &receivedOrder)
	
	if (err != nil) {
		println("Receive Order Error: ", err)
		return nil
	} else {
		return receivedOrder
	}
}







//Registers if any up-buttons is pushed
func checkButtonCallUp() {

	for (i:=0; i<N_FLOORS-1; i++) {
		if (elev_get_button_signal(BUTTON_CALL_UP, i)) {
			
			if (direction == -1 && floor == i) {
				go openDoor()
				doorOpen = false
				
			} else {
				//Regn ut egen cost og send newOrder
				cost := getCost(floor, i, direction, last_floor)
				newOrder := Order{floor, direction, i, 1, false}
				SetOrder(OrderList, newOrder)
				go SendOrder(newOrder)
				//Set en timer som hører etter svar, ta bestillingen selv om ingen svar etter timer går ut.
			}
		}
	}
}




//Registers if any down-buttons is pushed
func checkButtonCallDown() {

	for (i:=1; i<=N_FLOORS; i++) {
		if (elev_get_button_signal(BUTTON_CALL_DOWN, i)) {
			
			if (direction == -1 && floor == i) {
				//Ta order selv
				go openDoor()

			} else {
				//Regn ut egen cost og send newOrder
				cost := getCost(floor, i, direction, last_floor)
				newOrder := Order{floor, direction, i, 0, false}
				SetNewOrder(OrderList, newOrder)
				go SendOrder(newOrder)
				//Set en timer som hører etter svar, ta bestillingen selv om ingen svar etter timer går ut.
			}
		}
	}
}


//Registers if any command-buttons is pushed
func checkButtonCommand() {
	for (i:=0; i<4; i++) {
		if (elev_get_button_signal(BUTTON_COMMAND, i)) {
			if (direction == -1 && floor == i) {
				go openDoor()

			} else {
				newOrder := Order{floor, direction, i, -1, false}
				UpdateMyOrders(newOrder)
			}
		}
	}
}



func updateFloor() {
	floor = elev_get_floor_sensor_signal()
}



func openDoor() {

	doorOpen = true
	elev_set_door_open_lamp(1)
	Sleep(3*Second)
	elev_set_door_open_lamp(0)
	runElevator()
}

